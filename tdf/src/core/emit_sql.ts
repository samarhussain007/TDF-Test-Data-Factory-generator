// src/core/emit_sql.ts
import type { SchemaModel } from "../types/schema.js";
import type { GeneratedData } from "../types/data.js";
import { isDbGeneratedDefault } from "../models/schema.js";

/**
 * Emit INSERT statements for all generated data.
 */
export function emitSql(
  schema: SchemaModel,
  data: GeneratedData,
  tableOrder: string[],
): string {
  const lines: string[] = [];

  lines.push("-- Generated by TDF (Test Data Factory)");
  lines.push(`-- Generated at: ${new Date().toISOString()}`);
  lines.push("");
  lines.push("BEGIN;");
  lines.push("");

  for (const tableName of tableOrder) {
    const rows = data.get(tableName);
    if (!rows || rows.length === 0) continue;

    const tableSchema = schema.tables[tableName];
    if (!tableSchema) continue;

    const firstRow = rows[0];
    if (!firstRow) continue;

    lines.push(`-- Table: ${tableName} (${rows.length} rows)`);

    // Get column names from first row
    const columns = Object.keys(firstRow);

    // Filter out columns that shouldn't be inserted (DB-generated PKs like serial/identity/UUID)
    const insertColumns = columns.filter((col) => {
      const colSchema = tableSchema.columns[col];
      if (!colSchema) return true;
      // Skip columns with DB-generated defaults (nextval, gen_random_uuid, etc.)
      if (colSchema.isPrimaryKey && isDbGeneratedDefault(colSchema)) {
        return false;
      }
      return true;
    });

    for (const row of rows) {
      const values = insertColumns.map((col) => formatValue(row[col]));
      const columnsStr = insertColumns.map((c) => `"${c}"`).join(", ");
      const valuesStr = values.join(", ");

      lines.push(
        `INSERT INTO "${tableName}" (${columnsStr}) VALUES (${valuesStr});`,
      );
    }

    lines.push("");
  }

  lines.push("COMMIT;");
  lines.push("");

  return lines.join("\n");
}

/**
 * Format a value for SQL insertion.
 */
function formatValue(value: unknown): string {
  if (value === null || value === undefined) {
    return "NULL";
  }

  if (typeof value === "string") {
    return `'${escapeString(value)}'`;
  }

  if (typeof value === "number") {
    if (Number.isNaN(value)) {
      return "NULL";
    }
    if (!Number.isFinite(value)) {
      return value > 0 ? "'Infinity'" : "'-Infinity'";
    }
    return String(value);
  }

  if (typeof value === "boolean") {
    return value ? "TRUE" : "FALSE";
  }

  if (value instanceof Date) {
    return `'${value.toISOString()}'`;
  }

  if (Array.isArray(value)) {
    if (value.length === 0) {
      return "'{}'";
    }
    const elements = value.map((v) => {
      if (typeof v === "string") {
        return `"${escapeString(v)}"`;
      }
      return String(v);
    });
    return `'{${elements.join(",")}}'`;
  }

  if (typeof value === "object") {
    return `'${escapeString(JSON.stringify(value))}'::jsonb`;
  }

  return `'${escapeString(String(value))}'`;
}

/**
 * Escape a string for PostgreSQL.
 */
function escapeString(str: string): string {
  return str.replace(/'/g, "''").replace(/\\/g, "\\\\").replace(/\0/g, "");
}

/**
 * Emit a single table's INSERT statements.
 */
export function emitTableSql(
  tableName: string,
  rows: Record<string, unknown>[],
  columns: string[],
): string {
  if (rows.length === 0) return "";

  const lines: string[] = [];
  lines.push(`-- Table: ${tableName} (${rows.length} rows)`);

  for (const row of rows) {
    const values = columns.map((col) => formatValue(row[col]));
    const columnsStr = columns.map((c) => `"${c}"`).join(", ");
    const valuesStr = values.join(", ");

    lines.push(
      `INSERT INTO "${tableName}" (${columnsStr}) VALUES (${valuesStr});`,
    );
  }

  return lines.join("\n");
}
